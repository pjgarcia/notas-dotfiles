* 0x200 Programming
  + objdump -D -M intel a.out :: disassembly (-D) con formato Intel (-M intel)
  + gdb -q ./a.out :: debugger para ver el estado de la memoria y los registros al momento de ejecucion. No imprime
		      mensajes introductorios ni la licencia (-q o -quiet)
    + help <command> :: ayuda sobre el comando
    + break main :: pone un breakpoint en el label "main"
    + info registers :: imprime informacion sobre los registros en el momento actual de ejecucion
    + info register eip (short i r eip) :: informacion particularmente sobre el EIP
    + set disassembly-flavor intel :: cambia el formato de AT&T a Intel
    + list :: si fue compilado con *-g*, muestra el codigo fuente del programa
	      puede tomar argumentos como el #linea, nombre de la funcion, etc.
    + disassemble main :: desensambla la funcion deseada y la muestra
    + x/FORMAT ADRESS :: para *examinar* la memoria. FORMAT puede estar formado por:
      + n :: un numero para indicar la cantidad de "units" a examinar
      + t(binario) | o(octal) | u(decimal sin signo) | x(hexa) :: en que medida mostrar el "unit"
      + b(byte) | h(half word) | w(word default) | g(giant) :: tamanio del "unit"
      Por ejemplo, puede quedar asi: x, 2x, 4xb, etc.
      FORMAT tambien puede tomar valores como *i(instruccion), a(address), c(char), s(string)*.
      ADRESS es una expresion para la direccion de memoria a examinar. $eip o 0x8048384 por ejemplo.
    + print $ebp - 4 :: se usa para matematica simple, y guarda el resultado en una variable, para usarlo luego.
    + run :: corre el programa, parando en los breakpoints (si es que los hay)
    + continue (short cont) :: continua la ejecucion
    + nexti :: ejecutar la actual instruccion.
    + bt [full] o where :: backtrace the call stack. Con 'full' muestra las variables locales del stack frame
    + quit
  + EAX :: accumulator register
  + ECX :: counter register
  + EDX :: data register
  + EBX :: base register
  + ESP :: stack pointer
  + EBP :: base pointer
  + ESI EDI :: source and destination index: used to point to the source and dest when data needs to be read from or written to
  + EIP :: instruction pointer register
  + EFLAGS :: bit flags for comparisons and memory segmentation

  + bc -ql :: basic calculator

  + C variable global :: se declara igual a las demas, pero fuera de cualquier funcion

  + C variable estatica :: es local a la funcion en la que se declara, pero se comparte entre todos los 
       llamados a la misma
  
** 0x270 Memory Segmentation
   La memoria de un programa (compilado) esta dividida en 5 segmentos: text, data, bss, heap & stack
   + text segment :: tambien llamado /code segment/, es donde se guarda el codigo.
		     Tiene un tamanio fijo, ya que nunca nada cambia aqui, y /no/ es writeable.
		     El ser no-writeable permite seguridad y que se utilize para cada instancia de
		     el programa.
   + data & bss segments :: almacena las variables globales y estaticas. *data* tiene las variables
	inicializadas, mientras que *bss* tiene las /no/ inicializadas. Tiene tamanio fijo y es writeable.
   + heap segment :: segmento de memoria que el programador puede controlar directamente. /No/ tiene tamanio
		     fijo, ya que el programador puede almacenar y liberar bloques de memoria. El crecimiento
		     del heap es /graficamente/ hacia abajo, hacia posiciones de memoria mas grandes.
   + stack segment :: segmento para guardar las variables locales y el contexto de las funciones. Ya que
		      el contexto y el EIP deben cambiar cuando se llama a una funcion, se utiliza el stack
		      para recordar (este conjunto se llama *stack frame*):
     - las variables pasadas como argumentos
     - las variables locales de la funcion
     - SFP :: el *saved frame pointer* se usa para reestablecer el *EBP* a su anterior estado
     - return address :: puntero para poner el *EIP* en la posicion correspondiente al retornar
     El *EBP* (tambien llamado frame pointer) es un puntero usado para referenciar las variables locales 
     dentro del stack frame actual
     El stack no tiene tamanio fijo, y crece /graficamente/ hacia arriba, hacia las
     posiciones mas bajas de la memoria.
		      
   Al hacer un llamado a una funcion, el stack frame se compone con lo siguiente: 
   1) primero se pushean los argumentos a la funcion
   2) luego (en el call) se pushea la direccion de retorno
   3) se pushea el EBP, con lo que se lo almacena para luego recuperarlo cuando se debe retornar a ese contexto
   4) se apunta el EBP al actual SP, para tomar la pos. de las var locales en relacion a este punto
   5) se crea el espacio para almacenar las variables locales de la funcion

      
   		
** 0x280 Building on Basics
   Hay dos maneras principales para acceder a archivos desde C:
   + File Descriptors :: conjunto de funciones de *bajo nivel* de I/O
   + Filestreams :: buffered I/O construida sobre las otras funciones de bajo nivel
* 0x300 Exploitation
  La idea en [[file:~/workspace/hacking-taoe/0x300_Exploitation/exploit_notesearch.c::#include%20<stdio.h][exploit_notesearch.c]] es crear un buffer que tenga una serie de NOP's, las instrucciones 
  (shellcode) que queremos que se ejecuten, y un bloque de "return adresses" (RA).
  Ese buffer se appendea a un string del tipo "./notesearch ..." y se lo ejecuta con la funcion *system*.

  Una vez ejecutado el programa ./notesearch (vulnerable a buffer overflow en donde recibe el parametro a 
  buscar entre las notas del usuario), el overflow hace que se sobreescriba el stack (donde estan las
  variables locales) con el comando armado en *exploit_notesearch*. La idea es, en primer lugar, lograr 
  sobreescribir el return address con la deseada por nosotros. Como el lugar exacto del return address 
  dentro del stack frame puede variar por algunos bytes, se pone un bloque mediano con ese RA. 

  Como calculamos que RA ponerle? Considerando que las variables locales de *notesearch* estan por encima
  de las del main() de *exploit_notesearch* en el stack (posiciones de memoria mas bajas), podemos utilizar 
  la posicion de una variable de este ultimo y restarle X cantidad de bytes por la informacion anterior.
  Aqui se debe jugar con ese valor, pero teniendo en cuenta que queremos saltar a alguna parte de ese bloque
  de NOP's (para que la ejecucion termine cayendo al codigo inyectado) y que el stack frame de *notesearch*
  esta en posiciones mas bajas del stack.
  
  

    
