* 0x200 Programming
  + objdump -D -M intel a.out :: disassembly (-D) con formato Intel (-M intel)
  + gdb -q ./a.out :: debugger para ver el estado de la memoria y los registros al momento de ejecucion. No imprime
		      mensajes introductorios ni la licencia (-q o -quiet)
    + help <command> :: ayuda sobre el comando
    + break main :: pone un breakpoint en el label "main"
    + info registers :: imprime informacion sobre los registros en el momento actual de ejecucion
    + info register eip (short i r eip) :: informacion particularmente sobre el EIP
    + set disassembly-flavor intel :: cambia el formato de AT&T a Intel
    + list :: si fue compilado con *-g*, muestra el codigo fuente del programa
	      puede tomar argumentos como el #linea, nombre de la funcion, etc.
    + disassemble main :: desensambla la funcion deseada y la muestra
    + x/FORMAT ADRESS :: para *examinar* la memoria. FORMAT puede estar formado por:
      + n :: un numero para indicar la cantidad de "units" a examinar
      + t(binario) | o(octal) | u(decimal sin signo) | x(hexa) :: en que medida mostrar el "unit"
      + b(byte) | h(half word) | w(word default) | g(giant) :: tamanio del "unit"
      Por ejemplo, puede quedar asi: x, 2x, 4xb, etc.
      FORMAT tambien puede tomar valores como *i(instruccion), a(address), c(char), s(string)*.
      ADRESS es una expresion para la direccion de memoria a examinar. $eip o 0x8048384 por ejemplo.
    + print $ebp - 4 :: se usa para matematica simple, y guarda el resultado en una variable, para usarlo luego.
    + run :: corre el programa, parando en los breakpoints (si es que los hay)
    + continue (short cont) :: continua la ejecucion
    + nexti :: ejecutar la actual instruccion.
    + bt [full] o where :: backtrace the call stack. Con 'full' muestra las variables locales del stack frame
    + quit
  + EAX :: accumulator register
  + ECX :: counter register
  + EDX :: data register
  + EBX :: base register
  + ESP :: stack pointer
  + EBP :: base pointer
  + ESI EDI :: source and destination index: used to point to the source and dest when data needs to be read from or written to
  + EIP :: instruction pointer register
  + EFLAGS :: bit flags for comparisons and memory segmentation

  + bc -ql :: basic calculator

  + C variable global :: se declara igual a las demas, pero fuera de cualquier funcion

  + C variable estatica :: es local a la funcion en la que se declara, pero se comparte entre todos los 
       llamados a la misma
  
** 0x270 Memory Segmentation
   La memoria de un programa (compilado) esta dividida en 5 segmentos: text, data, bss, heap & stack
   + text segment :: tambien llamado /code segment/, es donde se guarda el codigo.
		     Tiene un tamanio fijo, ya que nunca nada cambia aqui, y /no/ es writeable.
		     El ser no-writeable permite seguridad y que se utilize para cada instancia de
		     el programa.
   + data & bss segments :: almacena las variables globales y estaticas. *data* tiene las variables
	inicializadas, mientras que *bss* tiene las /no/ inicializadas. Tiene tamanio fijo y es writeable.
   + heap segment :: segmento de memoria que el programador puede controlar directamente. /No/ tiene tamanio
		     fijo, ya que el programador puede almacenar y liberar bloques de memoria. El crecimiento
		     del heap es /graficamente/ hacia abajo, hacia posiciones de memoria mas grandes.
   + stack segment :: segmento para guardar las variables locales y el contexto de las funciones. Ya que
		      el contexto y el EIP deben cambiar cuando se llama a una funcion, se utiliza el stack
		      para recordar (este conjunto se llama *stack frame*):
     - las variables pasadas como argumentos
     - las variables locales de la funcion
     - SFP :: el *saved frame pointer* se usa para reestablecer el *EBP* a su anterior estado
     - return address :: puntero para poner el *EIP* en la posicion correspondiente al retornar
     El *EBP* (tambien llamado frame pointer) es un puntero usado para referenciar las variables locales 
     dentro del stack frame actual
     El stack no tiene tamanio fijo, y crece /graficamente/ hacia arriba, hacia las
     posiciones mas bajas de la memoria.
		      
   Al hacer un llamado a una funcion, el stack frame se compone con lo siguiente: 
   1) primero se pushean los argumentos a la funcion
   2) luego (en el call) se pushea la direccion de retorno
   3) se pushea el EBP, con lo que se lo almacena para luego recuperarlo cuando se debe retornar a ese contexto
   4) se apunta el EBP al actual SP, para tomar la pos. de las var locales en relacion a este punto
   5) se crea el espacio para almacenar las variables locales de la funcion

      
   		
** 0x280 Building on Basics
   Hay dos maneras principales para acceder a archivos desde C:
   + File Descriptors :: conjunto de funciones de *bajo nivel* de I/O
   + Filestreams :: buffered I/O construida sobre las otras funciones de bajo nivel
* 0x300 Exploitation
  La idea en [[file:~/workspace/hacking-taoe/0x300_Exploitation/exploit_notesearch.c::#include%20<stdio.h][exploit_notesearch.c]] es crear un buffer que tenga una serie de NOP's, las instrucciones 
  (shellcode) que queremos que se ejecuten, y un bloque de "return adresses" (RA).
  Ese buffer se appendea a un string del tipo "./notesearch ..." y se lo ejecuta con la funcion *system*.

  Una vez ejecutado el programa ./notesearch (vulnerable a buffer overflow en donde recibe el parametro a 
  buscar entre las notas del usuario), el overflow hace que se sobreescriba el stack (donde estan las
  variables locales) con el comando armado en *exploit_notesearch*. La idea es, en primer lugar, lograr 
  sobreescribir el return address (RA) del main con la deseada por nosotros. Como el lugar exacto del RA
  dentro del stack frame puede variar por algunos bytes, se pone un bloque mediano con ese RA repetido 
  para que alugno de todos ellos pise al verdadero.

  Luego de pisar el RA, cuando la funcion *main* termine de ejecutar y quiera retornar al lugar de donde
  fue llamada, el RA alterado va a hacer que salte hacia donde nosotros queremos. Esto es, el bloque de NOP's
  (no operation) que anteceden al shellcode. El objetivo de estos NOPs es crear un margen "grande" a donde 
  puede apuntar el RA, ya que no se puede saber con exactitud en que lugar del stack se va a ubicar el shellcode.
  El resultado es que la ejecucion pase por los NOP's y termine cayendo en el shellcode.

  Como estimamos que RA ponerle? Considerando que las variables locales de *notesearch* estan por encima
  de las del main() de *exploit_notesearch* en el stack (posiciones de memoria mas bajas), podemos utilizar 
  la posicion de una variable de este ultimo y restarle X cantidad de bytes por la informacion anterior.
  Aqui se debe jugar con ese valor, pero teniendo en cuenta que queremos saltar a alguna parte de ese bloque
  de NOP's (para que la ejecucion termine cayendo al codigo inyectado) y que el stack frame de *notesearch*
  esta en posiciones mas bajas del stack.
  
** Para probar el shellcode
   Escribir el binario con un editor hexa (mc o Emacs con hexl-mode sirven). Ahi vamos escribiendo los
   valores en hexadecimal, que luego pueden ser pasados por un programa como *objdump* para ver que
   instrucciones representan en assembler: ~objdump -D <file> -m i386 -b binary~
  
   La secuencia:
   31c0 31db 31c9 99b0 a4cd 806a 0b58 5168
   2f2f 7368 682f 6269 6e89 e351 89e2 5389 
   e1cd 80                              

   representa el siguiente codigo en asm:
#+NAME: shellcode
#+BEGIN_SRC asm
00000000 <.data>:
   0:   31 c0                   xor    %eax,%eax
   2:   31 db                   xor    %ebx,%ebx
   4:   31 c9                   xor    %ecx,%ecx
   6:   99                      cltd   
   7:   b0 a4                   mov    $0xa4,%al
   9:   cd 80                   int    $0x80
   b:   6a 0b                   push   $0xb
   d:   58                      pop    %eax
   e:   51                      push   %ecx
   f:   68 2f 2f 73 68          push   $0x68732f2f
  14:   68 2f 62 69 6e          push   $0x6e69622f
  19:   89 e3                   mov    %esp,%ebx
  1b:   51                      push   %ecx
  1c:   89 e2                   mov    %esp,%edx
  1e:   53                      push   %ebx
  1f:   89 e1                   mov    %esp,%ecx
  21:   cd 80                   int    $0x80
#+END_SRC
   
   La instruccion ~int $0x80 (syscall)~ es una interrupcion especial al kernel. Expresa que el programa le esta
   pidiendo una accion especial al kernel. El interrupt 0x80 toma de EAX el llamado a realizar. En este caso,
   resulta ~eax = 0xa4 (164)~, que, viendo en [[/usr/include/i386-linux-gnu/asm/unistd_32.h][unistd_32.h]], significa que se va a ejecutar la funcion 
   *setresuid* (existe una funcion wrapper en C, de ese nombre).

   La proxima interrupcion ~int $0x80~ se hace con el valor 0xb en EAX, por lo que se ejecuta la funcion
   *execve* (ejecutar programa).

   Para que el shellcode (que se aloja en el stack) pueda ejecutarse, el programa debe compilarse sin algunas 
   medidas de seguridad, esto es:
   + -fno-stack-protector
   + -z execstack
